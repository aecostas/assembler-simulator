app.service('assembler', ['opcodes', function (opcodes) {
    return {
        go: function (input) {
            // Use https://www.debuggex.com/
            // Matches: "label: INSTRUCTION (["')OPERAND1(]"'), (["')OPERAND2(]"')
            // GROUPS:      1       2               3                    7
	    var regex = /(LD|ST|ADD|BR|BZ)\s+(\/[1-9]+)|(DEC|HALT|CLR)\s+;.*/;

            // Regex group indexes for operands
            var op1_group = 3;
            var op2_group = 7;

	    var CO_field = {
		'ST':0,
		'LD':1,
		'ADD':2,
		'BR':3,
		'BZ':4,
		'CLR':5,
		'DEC':6,
		'HALT':7
	    };

	    // MATCHES: "(+|-)INTEGER"
            var regexNum = /^[-+]?[0-9]+$/;
            // MATCHES: "(.L)abel"
            var regexLabel = /^[.A-Za-z]\w*$/;
            // Contains the program code & data generated by the assembler
            var code = [];
            // Contains the mapping from instructions to assembler line
            var mapping = {};
            // Hash map of label used to replace the labels after the assembler generated the code
            var labels = {};
            // Hash of uppercase labels used to detect duplicates
            var normalizedLabels = {};

            // Split text into code lines
            var lines = input.split('\n');

	    /**
	     * Parse the address field. Return the number
	     * representation or throws an error
	     *
	     * @param [String] address - address read from the assembly language
	     */
	    var parseAddress = function(address) {
		var value;
		if (address[0] !== '/') {
		    throw "Invalid number format";
		};

		value = Number(address.substring(1)).toString(16);
		return value;
	    };
	    
	    
            // Allowed formats: 200, 200d, 0xA4, 0o48, 101b
            var parseNumber = function (input) {
                if (input.slice(0, 2) === "0x") {
                    return parseInt(input.slice(2), 16);
                } else if (input.slice(0, 2) === "0o") {
                    return parseInt(input.slice(2), 8);
                } else if (input.slice(input.length - 1) === "b") {
                    return parseInt(input.slice(0, input.length - 1), 2);
                } else if (input.slice(input.length - 1) === "d") {
                    return parseInt(input.slice(0, input.length - 1), 10);
                } else if (regexNum.exec(input)) {
                    return parseInt(input, 10);
                } else {
                    throw "Invalid number format";
                }
            };


            var parseLabel = function (input) {
                return regexLabel.exec(input) ? input : undefined;
            };


            var checkNoExtraArg = function (instr, arg) {
                if (arg !== undefined) {
                    throw instr + ": too many arguments";
                }
            };

            for (var i = 0, l = lines.length; i < l; i++) {
		if (lines[i].trim().length == 0) {
		    continue;
		};

                var match = regex.exec(lines[i]);
		var instr = match[1].toUpperCase();
		
		// TODO: check errors
		// if CO_FIELD[instr] undefined
		code.push(CO_field[instr]);

		switch (instr) {
		case 'LD':
		case 'ST':
		case 'ADD':
		case 'BR':
		case 'BZ':
		    // TODO: as a future improvement, we could
		    // allow to parse all the file to show the errors
		    // on the screen. Current implementation will throw
		    // an error
		    code.push(parseAddress(match[2]));
		    break;
		    
		case 'CLR':
		case 'DEC':
		case 'HALT':
		    // check no extra args
		    break;
		}
		
		// Add mapping instr pos to line number
		mapping[code.length] = i;
	    } // for
	    
	    console.warn(code);
	    console.warn(mapping);

            return {code: code, mapping: mapping, labels: labels};
        }
    };
}]);
